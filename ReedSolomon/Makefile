#MAKEFLAGS += --no-builtin-rules  #black magic removal
# Note: 
# If the .d (dependency) files are manually removed the dependencies for include files will not
# get picked up unless there is a change in the .c file or until the next "make clean" is executed.
CFLAGS += -g -O0 -Wall -Wextra -Werror

SRC_DIR := ./src/
INC_DIRS := ./inc/
OBJ_DIR := ./obj/
# .c files in this directory have a main function in them and are thus mutually exclusive when linking
APPS_DIR := ./apps/

# gets a list of all applications in the apps dir for filtering build targets
APP_LIST := $(basename $(shell find $(APPS_DIR) -type f -printf "%f\n"))

# The name of the executable to build -- it will end up in the working directory
BUILD_TARGET := $(filter $(APP_LIST),$(MAKECMDGOALS))

# Following are the search paths for prerequisites 
vpath %.h $(INC_DIRS)	# Include file search path includes the source path  -- This should also be conveyed to the complile rule
vpath %.c $(SRC_DIR) $(APPS_DIR)
#vpath %.d $(OBJ_DIR)

# Add a prefix to INC_DIRS to add the "-I" compile flag 
INC_FLAGS := $(addprefix -I,$(INC_DIRS))
CPPFLAGS := $(INC_FLAGS) -MMD -MP #-MMD and -MP generates the .d files when a .c file is compiled

# Manually entering the obj targets
#OBJfiles := sub.o main.o	
#OBJECTS := $(patsubst %, $(OBJ_DIR)%, $(OBJfiles))	# Creates the object target list in the OBJ_DIR folder

#Automatically scanning for source files and creating .o targets from .c files found
# create object target list by searching for .c files in the source path and then  switch .c with .o and substitute the obj path for the src 
TARGET_SRC := $(APPS_DIR)$(BUILD_TARGET).c
TARGET_OBJ := $(subst $(APPS_DIR),$(OBJ_DIR),$(TARGET_SRC:.c=.o))

APP_SOURCES := $(shell find $(APPS_DIR) -name "*.c")
APP_OBJECTS := $(subst $(APPS_DIR),$(OBJ_DIR),$(APP_SOURCES:.c=.o))
APP_DEPS := $(APP_OBJECTS:.o=.d)	# there might be a way to trick around with picking up executable object dependencies but how do you first generate them?

SOURCES := $(shell find $(SRC_DIR) -name "*.c")
OBJECTS := $(subst $(SRC_DIR),$(OBJ_DIR),$(SOURCES:.c=.o))

# String substitution (suffix version without %).
# As an example, ./build/hello.cpp.o turns into ./build/hello.cpp.d
DEPS := $(OBJECTS:.o=.d) $(APP_DEPS)

#####   First Target -- This is what gets built by default #####
.PHONY: all
all: $(OBJECTS) $(APP_OBJECTS)
	@echo compiled all objects

$(BUILD_TARGET) :$(OBJECTS) $(TARGET_OBJ)	# This will drive the creation of the .o files in the OBJdir for the prerequisites 
	@#echo "$@ link rule"
	$(CC) $(LDFLAGS) $(TARGET_ARCH) $^ $(LOADLIBES) $(LDLIBS) -o $@

# the compile rule for the prerequisites of the final target -- 
$(OBJ_DIR)%.o : %.c				# pattern rule picks up the .c as a pre-req for a .o
	@#echo "MY pattern rule .c to .o via OBJ_DIR"
	@mkdir -p '$(@D)'
	$(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@

.PHONY: clean
clean:
	@echo cleaning $(OBJ_DIR)
	@rm -rf $(OBJ_DIR)			# removing all of the OBJS forces a complete re-compile / re-link
	@rm -f *.exe				# just for good measure remove the exe as well 

# see automatic generation via -MMD -MP and include $(DEPS) below
-include $(DEPS)


# some built in default variables from make -- as displayed by make -p
#LINK.c =  														% : %c
#$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)  		$^ $(LOADLIBES) $(LDLIBS) -o $@

#LINK.o =  														% : %.o
# $(CC) $(LDFLAGS) $(TARGET_ARCH) 								$^ $(LOADLIBES) $(LDLIBS) -o $@

#COMPILE.c =  													%.o : %.c  
#$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c 					$(OUTPUT_OPTION) $<


# Include the .d makefiles. The - at the front suppresses the errors of missing
# Makefiles. Initially, all the .d files will be missing, and we don't want those
# errors to show up.

#some example dependencies 
# The internal dependencies for the various object targets  No need to specify the .c file here, it gets picked up by the compile pattern rule
# This should get generated by the compiler and then included as a seperate file -- Note that the $(OBJ_DIR) path has to be pre-pended 
#$(OBJ_DIR)main.o:min.h max.h		# no need to specify the .c file, it gets picked up by the %.o : %.c pattern rule
#$(OBJ_DIR)main.o:defs.h			# add one more dependency -- this one is found in the second vpath entry for .h
#$(OBJ_DIR)sub.o: defs.h			# this indicates that def.h is a prerequisit for sub.o file only
# example of multiple targets depending on the same pre-req
#$(OBJ_DIR)main.o $(OBJ_DIR)/sub.o : defs.h	# this indicates that def.h is a prerequisit for both .o files 

